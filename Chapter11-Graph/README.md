# 11. 그래프
## 11-1 그래프의 개념
노드와 간선을 이용한 비선형 데이터 구조
### 그래프 용어 정리
간선, 가중치, 정점
### 그래프의 특징과 종류
방향성, 가중치, 순환 특성에 따라 종류를 구분
### 흐름을 표현하는 방향성
방향 그래프, 무방향 그래프
### 흐름의 정도를 표현하는 가중치
데이터의 양 가중치, 가중치 그래프
### 시작과 끝의 연결 여부를 보는 순환
순환 그래프, 비순환 그래프
## 그래프 구현
노드, 간선, 방향, 가중치
### 인접 행렬 그래프 표현
### 인접 리스트 그래프 표현
[v, w]로 묶어서 vector에 넣기
```c++
#include <iostream>
#include <vector>
using namespace std;

struct nodeInfo
{
	int V;
	int W;
};

vector<vector<nodeInfo>> adjList;

void addEdge(int u, int v, int w)
{
	adjList[u].push_back({v, w});
}

void printAdjList()
{
	for (int i = 0; i < adjList.size(); ++i)
	{
		cout << "Node " << i << ":";
		for (const auto& node : adjList[i])
		{
			cout << " -> (V: " << node.V << ", W: " << node.W << ")";
		}
		cout << endl;
	}
}

int main()
{
	int N = 5;
	adjList.resize(N);

	addEdge(1, 2, 3);
	addEdge(2, 1, 6);
	addEdge(2, 3, 5);
	addEdge(3, 2, 1);
	addEdge(3, 4, 13);
	addEdge(4, 4, 9);
	addEdge(4, 1, 42);

	printAdjList();

	return 0;
}
```

### 인접 행렬과 인접 리스트의 장단점
#### 인접 행렬의 장단점
V X V
O(1) 시간 복잡도가 O(1)
#### 인접 리스트의 장단점
간선의 수를 E
O(E)
그래프의 모든 간선을 찾는 경우 시간 복잡도
O(V + E)

## 11-2 그래프 탐색
더 이상 탐색할 노드가 없을 때까지(깊이 우선 탐색)
현재 위치에서 가장 가까운 노드부터 모두 방문하고 다음 노드로 넘어감(너비 우선 탐색)
### 깊이 우선 탐색
시작 노드부터 탐색을 시작하여 간선을 따라 최대 깊이 노드까지 이동
1. 스택이 비었는지 확인 비어있으면 모든 노드를 방문
2. 스택에서 노드를 팝함. 팝한 원소는 최근에 스택에 푸시한 노드
3. 팝한 노드의 방문 여부를 확인. 아직 방문하지 않았다면 노드를 방문 처리
4. 아직 방문하지 않은 노드를 스택에 푸시
#### 스택을 활용한 깊이 우선 탐색
### 재귀 함수를 활용한 깊이 우선 탐색
### 너비 우선 탐색
#### 큐를 활용한 너비 우선 탐색
### 깊이 우선 탐색과 너비 우선 탐색 비교
깊이 우선 탐색은 깊게 탐색 후 되돌아오는 특성이 있고, 너비 우선 탐색은 시작 노드에서 인접한 노드부터 방문하는 특성을 가집니다.
#### 깊이 탐색 후 되돌아오는 깊이 우선 탐색
최단 경로를 찾는 문제가 아니면 깊이 우선 탐색을 우선 고려해보는 것이 좋음
모든 가능한 해를 찾는 백트래킹 알고리즘을 구현할 때나 그래프의 사이클을 감지해야 하는 경우 활용할 수 있습니다.
#### 최단 경로를 보장하는 너비 우선 탐색
시작 노드로부터 최단 경로임을 보장합니다.

## 11-3 그래프 최단 경로 구하기
### 다익스트라 알고리즘
### 벨만-포드 알고리즘
(음의 가중치 고려)
### 플로이드-워셜 알고리즘
모든 노드에서의 최단 경로를 모두 구하는 알고리즘

